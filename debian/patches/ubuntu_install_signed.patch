Description: Install signed images if UEFI Secure Boot is enabled
Author: Colin Watson <cjwatson@ubuntu.com>
Forwarded: no
Last-Update: 2012-12-10

Index: b/util/grub-install.in
===================================================================
--- a/util/grub-install.in
+++ b/util/grub-install.in
@@ -60,6 +60,12 @@
 
 removable=no
 efi_quiet=
+sb_var=/sys/firmware/efi/vars/SecureBoot-8be4df61-93ca-11d2-aa0d-00e098032b8c/data
+if [ -e "$sb_var" ] && [ "$(printf %x \'"$(cat "$sb_var")")" = 1 ]; then
+  uefi_secure_boot=yes
+else
+  uefi_secure_boot=no
+fi
 
 # Get GRUB_DISTRIBUTOR.
 if test -f "${sysconfdir}/default/grub" ; then
@@ -125,6 +131,12 @@
     cat <<EOF
    --removable             the installation device is removable
    --bootloader-id=ID      the ID of bootloader.
+   --uefi-secure-boot      install an image usable with UEFI Secure Boot
+                           (only available if the grub-efi-amd64-signed
+                           package is installed)
+   --no-uefi-secure-boot   do not install an image usable with UEFI Secure
+                           Boot, even if the system was currently started
+                           using it
 EOF
 fi
     cat <<EOF
@@ -250,6 +262,11 @@
     -f | --force)
         setup_force="--force" ;;
 
+    --uefi-secure-boot)
+	uefi_secure_boot=yes ;;
+    --no-uefi-secure-boot)
+	uefi_secure_boot=no ;;
+
     -*)
 	echo "Unrecognized option \`$option'" 1>&2
 	usage
@@ -352,39 +369,32 @@
         # not collide with other vendors.  To minimise collisions, we use the
         # name of our distributor if possible.
 	efi_distributor="$bootloader_id"
+	# It is convenient for each architecture to have a different
+	# efi_file, so that different versions can be installed in parallel.
+	case "$target_cpu" in
+	    i386)
+		efi_suffix=ia32 ;;
+	    x86_64)
+		efi_suffix=x64 ;;
+	# GRUB does not yet support these architectures, but they're defined
+	# by the specification so we include them here to ease future
+	# expansion.
+	    ia64)
+		efi_suffix=ia64 ;;
+	    *)
+		efi_suffix= ;;
+	esac
 	if test $removable = yes; then
       	   # The specification makes stricter requirements of removable
 	   # devices, in order that only one image can be automatically loaded
 	   # from them.  The image must always reside under /EFI/BOOT, and it
 	   # must have a specific file name depending on the architecture.
 	    efi_distributor=BOOT
-	    case "$target_cpu" in
-		i386)
-		    efi_file=BOOTIA32.EFI ;;
-		x86_64)
-		    efi_file=BOOTX64.EFI ;;
-	    # GRUB does not yet support these architectures, but they're defined
-	    # by the specification so we include them here to ease future
-	    # expansion.
-		ia64)
-		    efi_file=BOOTIA64.EFI ;;
-	    esac
+	    efi_file="BOOT$(printf %s "$efi_suffix" | tr a-z A-Z).EFI"
 	else
 	    # It is convenient for each architecture to have a different
 	    # efi_file, so that different versions can be installed in parallel.
-	    case "$target_cpu" in
-		i386)
-		    efi_file=grubia32.efi ;;
-		x86_64)
-		    efi_file=grubx64.efi ;;
-	 # GRUB does not yet support these architectures, but they're defined
- 	 # by the specification so we include them here to ease future
-	 # expansion.
-		ia64)
-		    efi_file=grubia64.efi ;;
-		*)
-		    efi_file=grub.efi ;;
-	    esac
+	    efi_file="grub$efi_suffix.efi"
 	   # TODO: We should also use efibootmgr, if available, to add a Boot
 	   # entry for ourselves.
 	fi
@@ -485,13 +495,13 @@
 fi
 
 prefix_drive=
-config_opt=
+config_opt_file=
 
 rm -f "${grubdir}/load.cfg"
 
 if [ "x${debug_image}" != x ]; then
     echo "set debug='${debug_image}'" >> "${grubdir}/load.cfg"
-    config_opt="-c ${grubdir}/load.cfg "
+    config_opt_file="${grubdir}/load.cfg"
 fi
 
 if [ "x${devabstraction_module}" = "x" ] ; then
@@ -508,7 +518,7 @@
     # Strip partition number
     grub_partition="`echo "${grub_drive}" | sed -e 's/^[^,]*[,)]//; s/)$//'`"
     grub_drive="`echo "${grub_drive}" | sed -e s/,[a-z0-9,]*//g`"
-    if [ "$disk_module" = ata ] || [ "x${grub_drive}" != "x${install_drive}" ] || ([ "x$platform" != xefi ] && [ "x$platform" != xpc ] && [ x"${target_cpu}-${platform}" != x"sparc64-ieee1275" ]) ; then
+    if [ "$disk_module" = ata ] || [ "x${grub_drive}" != "x${install_drive}" ] || ([ "x$platform" != xefi ] && [ "x$platform" != xpc ] && [ x"${target_cpu}-${platform}" != x"sparc64-ieee1275" ]) || ([ "x$platform" = xefi ] && [ "$uefi_secure_boot" = yes ]); then
         # generic method (used on coreboot and ata mod)
         uuid="`"$grub_probe" --device-map="${device_map}" --target=fs_uuid --device "${grub_device}"`"
         if [ "x${uuid}" = "x" ] ; then
@@ -524,7 +534,7 @@
         fi
         echo "search.fs_uuid ${uuid} root " >> "${grubdir}/load.cfg"
 	echo 'set prefix=($root)'"${relative_grubdir}" >> "${grubdir}/load.cfg"
-	config_opt="-c ${grubdir}/load.cfg "
+	config_opt_file="${grubdir}/load.cfg"
         modules="$modules search_fs_uuid"
     elif [ "x$platform" = xefi ] || [ "x$platform" = xpc ]; then
         # we need to hardcode the partition number in the core image's prefix.
@@ -552,7 +562,11 @@
 esac
 
 
-"$grub_mkimage" ${config_opt} -d "${pkglibdir}" -O ${mkimage_target} --output="${grubdir}/core.${imgext}" --prefix="${prefix_drive}${relative_grubdir}" $modules || exit 1
+if [ x"$config_opt_file" = x ]; then
+    "$grub_mkimage" -d "${pkglibdir}" -O ${mkimage_target} --output="${grubdir}/core.${imgext}" --prefix="${prefix_drive}${relative_grubdir}" $modules || exit 1
+else
+    "$grub_mkimage" -c "${config_opt_file}" -d "${pkglibdir}" -O ${mkimage_target} --output="${grubdir}/core.${imgext}" --prefix="${prefix_drive}${relative_grubdir}" $modules || exit 1
+fi
 
 # Backward-compatibility kludges
 if [ "${target_cpu}-${platform}" = "mips-yeeloong" ]; then
@@ -560,7 +574,11 @@
 elif [ "${target_cpu}-${platform}" = "i386-ieee1275" ] || [ "${target_cpu}-${platform}" = "powerpc-ieee1275" ]; then
     cp "${grubdir}/core.${imgext}" "${grubdir}/grub"
 elif [ "${target_cpu}-${platform}" = "i386-efi" ] || [ "${target_cpu}-${platform}" = "x86_64-efi" ]; then
-    "$grub_mkimage" ${config_opt} -d "${pkglibdir}" -O ${mkimage_target} --output="${grubdir}/grub.efi" --prefix="" $modules || exit 1
+    if [ x"$config_opt_file" = x ]; then
+	"$grub_mkimage" -d "${pkglibdir}" -O ${mkimage_target} --output="${grubdir}/grub.efi" --prefix="" $modules || exit 1
+    else
+	"$grub_mkimage" -c "${config_opt_file}" -d "${pkglibdir}" -O ${mkimage_target} --output="${grubdir}/grub.efi" --prefix="" $modules || exit 1
+    fi
 fi
 
 
@@ -606,10 +624,32 @@
 	}
     fi
 elif [ x"$platform" = xefi ]; then
-    cp "${grubdir}/core.${imgext}" "${efidir}/${efi_file}"
-    # For old macs. Suggested by Peter Jones.
-    if [ x$target_cpu = xi386 ]; then
-	cp "${grubdir}/core.${imgext}" "${efidir}/boot.efi"
+    if [ $removable = yes ]; then
+	efi_signed="${pkglibdir}-signed/gcd$efi_suffix.efi.signed"
+    else
+	efi_signed="${pkglibdir}-signed/grub$efi_suffix.efi.signed"
+    fi
+    if [ "$uefi_secure_boot" = yes ] && [ -e "$efi_signed" ]; then
+	shim_signed=/usr/lib/shim/shim.efi.signed
+	if [ -e "$shim_signed" ]; then
+	    if [ "$removable" != yes ]; then
+		efi_file="shim$efi_suffix.efi"
+	    fi
+	    cp "$shim_signed" "${efidir}/${efi_file}"
+	    cp "$efi_signed" "${efidir}/grub$efi_suffix.efi"
+	else
+	    cp "$efi_signed" "${efidir}/${efi_file}"
+	fi
+	if [ x"$config_opt_file" != x ]; then
+	    cp "${config_opt_file}" "${efidir}/grub.cfg"
+	    echo 'configfile $prefix/grub.cfg' >> "${efidir}/grub.cfg"
+	fi
+    else
+	cp "${grubdir}/core.${imgext}" "${efidir}/${efi_file}"
+	# For old macs. Suggested by Peter Jones.
+	if [ x$target_cpu = xi386 ]; then
+	    cp "${grubdir}/core.${imgext}" "${efidir}/boot.efi"
+	fi
     fi
 
     # Try to make this image bootable using the EFI Boot Manager, if available.
